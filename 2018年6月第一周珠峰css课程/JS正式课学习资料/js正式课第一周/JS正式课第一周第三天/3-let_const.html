<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="" name="Keywords">
    <meta content="" name="description">
    <title>let_const</title>
    <link rel="icon" href="">

</head>
<body>
<div id="div1">let_const</div>

</body>
</html>
<script>

    // let const 都属于ES6 的内容
    // let 声明 的变量 没有变量提升；而且 他也不是 window上的一个属性
    // let 不能重复声明 重复声明会报错 ； 可以重新赋值
    // const 不能重新赋值 跟let基本一样都不是window的属性


   /* var a=12;
    b=13;*/
   // let a=12;
  //  a=13;
  //  console.log('a' in window);// false
  //  const  b=14; //常量不能变的量 不能重新赋值

   /*let a=12;
    function f() {
        console.log(a);//12
    }
    function f1() {
        console.log(b,a);//报错 a is not undefined
        let a=15;
        var b=10;
        console.log(a);
    }
    f();
    f1();
*/
    /*
    * 在函数执行的时候，形成的私有作用域中，
    * 用var 声明过的变量，会有变量提升，给一个默认值是undefined
    * 用let 和 const 声明的变量，不会进行变量提升，但是他也会对里边的带let 和const 的变量进行预览，这时，浏览器不会再往上级作用域查找相应的变量
    * 暂时性死区
    *
    * */

    /*
    * 全局作用域
    * 私有作用域 ： 函数执行的时候形成的
    * ES6 块级作用域 {}  for   if   while
    * 块级作用域 ： 只对let 或者 const 声明的变量起作用； 对于var 没有块级作用域的限制
    *
    * */

    if(true){
       let aa=12;
    }
   // console.log(aa);// 报错 aa is not defined

    if(true){
        var bb=13;
    }
    console.log(bb);// 13

    // 一个变量第一次出现可以赋值但是不能调用
    console.log(g);//报错
    console.log(typeof  g);// 'undefined'
    //----------------------------------------
    console.log(typeof  f);// 报错  Identifier 'f' has already been declared at <anonymous>:1:1
    let f=12;
//-------------------------------------------




</script>