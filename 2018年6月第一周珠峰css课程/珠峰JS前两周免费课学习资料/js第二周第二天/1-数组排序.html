<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="" name="Keywords">
    <meta content="" name="description">
    <title>Title</title>
    <link rel="icon" href="">

</head>
<body>


</body>
</html>
<script>
    /*
    * 数组排序  sort
    * 1、冒泡排序
    * */
    /*var ary=[2,5,3,6,8,11,15,13];
    // 两项两项比较，如果后一项比前一项大，则不交换顺序，否则两者交换顺序
    function myMao(ary) {

        for (var i = 0; i < ary.length-1; i++) {
            for (var j = 0; j < ary.length-1-i; j++) {
                var  max=ary[j];
                if(max>ary[j+1]){
                    ary[j]=ary[j+1];
                    ary[j+1]=max;
                }
            }

        }
     return ary;
    }

    console.log(myMao(ary));
*/

    //快速排序
    // 递归 ---> 在这里 就是 让函数 自己调用自己

   /* function sum(n) {
        if(n>0){
          return  n+sum(n-1);
        }
        return 0;
    }*/
//------------------------------------

  /*  function sum1(n) {
        if(n<0){
            return 0;
        }
        return n+sum(n-1);
    }

    console.log(sum1(2));//1+2=3
*/
    // 需求 能被2 或 3整除的数 相加求和
    /*function sum3(n) {
         if(n<=0){
             return 0;  // 函数边界，要不然死循环
         }
         else if(n%2==0||n%3==0){
             return n+sum3(n-1);
        }
        return sum3(n-1)
    }
    console.log(sum3(100));*/
    //-----------------------------------
 //用递归实现快速排序
    // 思路：从数组的中间部分取出一个值 ，然后用 取出数值后的数组的每一项 跟取出的这个数比较，把比他大的放到一个数组中，比他小的放到另一个数组中；
    //然后再把新的这两个数组重复刚才的步骤，把结果 拼成一个新的数组

function fn(ary) {

    if(ary.length<=1){
    return ary;
        }
    var n=parseInt(ary.length/2);// 中间项的索引
    var temp=ary.splice(n,1)[0];   //中间项的值
    var left=[],right=[];

    for (var i = 0;i <ary.length; i++) {

        if(ary[i]<=temp){
            left.push(ary[i]);
        }else{
            right.push(ary[i]);
        }
    }
    return  fn(left).concat(temp,fn(right));
}

    var ary1=[4,1,3,2,7];
    console.log(fn(ary1));



</script>